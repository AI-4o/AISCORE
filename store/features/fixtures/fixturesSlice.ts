import { createAsyncThunk, createSlice } from "@reduxjs/toolkit";
import { Fixture, FixtureResponse } from "api/api-football/models/fixture";
import { League } from "api/api-football/models/league";
import mockFixtures from "api/api-football/mock-responses/mock-fixtures/mock-fixtures-1.json";
import { getAPIFootballParams } from "@/app/api/api-football/api-call.defs";
import { config } from "appConfig";
import qs from "qs";

export interface FixturesState {
  fixtures: (Fixture & { isFavorite: boolean })[];
  leagues: (League & { isFavorite: boolean })[];
  status: "idle" | "loading" | "failed";
}

const initialState: FixturesState = {
  fixtures: [],
  leagues: [],
  status: "idle",
};

// Slice -> used to create in 1 place reducers and actions logic,
// - slice.actions returns the action creators
// - slice.reducer returns the reducer
export const fixturesSlice = createSlice({
  name: "fixtures",
  initialState,
  reducers: {
    toggleFavoriteFixture: (state, action) => {
      const fixture = state.fixtures.find(
        (fixture) => fixture.fixture.id === action.payload
      );
      if (fixture) {
        fixture.isFavorite = !fixture.isFavorite;
        const league = state.leagues.find(
          (league) => league.id === getLeagueIdFromFixture(fixture)
        );
        if (league) {
          if (fixture.isFavorite) {
            // se fixture è stato aggiunto come preferito, aggiorniamo il valore di isFavorite del league
            league.isFavorite = true;
          } else {
            // se fixture è stato rimosso come preferito, aggiorniamo il valore di isFavorite del league
            const noFixtureIsFavorite = getFixturesOfLeague(state.fixtures, league.id).every((fixture) => !fixture.isFavorite);
            console.log("noFixtureIsFavorite: ", noFixtureIsFavorite);
            if (noFixtureIsFavorite) league.isFavorite = false;
          }
        }
      }
    },
    toggleFavoriteLeague: (state, action) => {
      const league = state.leagues.find(
        (league) => league.id == action.payload
      );

      console.log(
        "toggleFavoriteLeague: ",
        action.payload,
        state.leagues,
        league
      );
      if (league) {
        league.isFavorite = !league.isFavorite;
        const fixturesOfLeague = getFixturesOfLeague(state.fixtures, league.id);
        if (league.isFavorite) {
          // se league è stato aggiunto come preferito, aggiorniamo il valore di isFavorite dei fixture di quella league
          fixturesOfLeague.forEach((fixture) => {
            fixture.isFavorite = true;
          });
        } else {
          // se league è stato rimosso come preferito, aggiorniamo il valore di isFavorite dei fixture di quella league
          fixturesOfLeague.forEach((fixture) => {
            fixture.isFavorite = false;
          });
        }
      }
    },
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
      // Handle the action types defined by the `incrementAsync` thunk defined below.
      // This lets the slice reducer update the state with request status and results.
      .addCase(fetchFixtures.pending, (state) => {
        state.status = "loading";
      })
      .addCase(fetchFixtures.fulfilled, (state, action) => {
        state.status = "idle";

        // set state of fixtures
        const fixtures = action.payload
          .map((fixtureResponse) => fixtureResponse.response)
          .flat()
          // settiamo isFavorite a false per default
          .map((fixture) => ({ ...fixture, isFavorite: false })); // TODO: se l'utente loggato, prendiamo il valore da db

        // set state of leagues
        const leagues = Array.from(
          new Map(
            fixtures
              .map((fixture) => fixture.league)
              .map((league) => [league.id, { ...league, isFavorite: false }])
          ).values()
        ); // TODO: se l'utente loggato, prendiamo il valore da db

        console.log("fixtures: ", fixtures);
        console.log("leagues: ", leagues);

        state.fixtures = fixtures;
        state.leagues = leagues;
      })
      .addCase(fetchFixtures.rejected, (state) => {
        state.status = "failed";
      });
  },
});

export default fixturesSlice.reducer;
export const { toggleFavoriteFixture, toggleFavoriteLeague } =
  fixturesSlice.actions;

export const fetchFixtures = createAsyncThunk(
  "fixtures/fetchFixtures",
  async (params: getAPIFootballParams) => {
    let response: FixtureResponse[];
    if (!config.mockAPICall) {
      console.log("params in the fetchFixtures slice: ", params.queryParams);
      // perform the api call if no fixtureResponse is provided
      response = await fetch(
        `/api/api-football/get-fixtures` +
          `${qs.stringify(params.queryParams)}`,
        {
          method: "GET",
          headers: {
            "Content-Type": "application/json",
          },
        }
      ).then(async (res) => {
        return (await res.json()) as FixtureResponse[];
      });
    } else {
      // return the mock fixtures
      response = [mockFixtures] as unknown as FixtureResponse[];
      console.log("mock response at slice level: ", response);
    }
    return response;
  }
);

const getFixturesIds = (fixtures: Fixture[]) => {
  return fixtures.map((fixture) => fixture.fixture.id);
};

const getLeaguesIds = (leagues: League[]) => {
  return leagues.map((league) => league.id);
};

export const getLeagueIdFromFixture = (fixture: Fixture) => {
  return fixture.league.id;
};

export const getFixturesOfLeague = (
  fixtures: Fixture[],
  leagueId: number
): (Fixture & { isFavorite: boolean })[] => {
  return fixtures.filter(
    (fixture) => fixture.league.id === leagueId
  ) as (Fixture & { isFavorite: boolean })[];
};
