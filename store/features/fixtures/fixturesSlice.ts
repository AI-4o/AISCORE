import { createAsyncThunk, createSlice } from "@reduxjs/toolkit";
import {
  FavoriteFixture,
  FavoriteLeague,
  FavoriteLeagueFixture,
  FixtureResponse,
} from "@/app/api/api-football/models/footballModels";
import mockFixtures from "api/api-football/mock-responses/mock-fixtures/mock-fixtures-1.json";
import { getAPIFootballParams } from "@/app/api/api-football/api-call.defs";
import { config } from "appConfig";
import qs from "qs";
import { compareDates, formatDateToYYYYMMDD } from "@/app/lib/utils";

export interface FootballState {
  fixtures: FavoriteFixture[];
  leagues: FavoriteLeague[];
  leaguesFixtures: FavoriteLeagueFixture[];
  status: "idle" | "loading" | "failed";
}

const initialState: FootballState = {
  fixtures: [],
  leagues: [],
  leaguesFixtures: [],
  status: "idle",
};
// Slice -> used to create in 1 place reducers and actions logic,
// - slice.actions returns the action creators
// - slice.reducer returns the reducer
export const footballSlice = createSlice({
  name: "fixtures",
  initialState,
  reducers: {
    toggleFavoriteFixture: (s, action) => {
      const leagueFixtures = s.leaguesFixtures.find( // find the leagueFixtures object associated to the fixture
        (leagueFixture) => leagueFixture.fixtures.find(f => f.fixture.id === action.payload)
      )
      const p = {
        league: leagueFixtures?.league,
        fixture: leagueFixtures?.fixtures.find(f => f.fixture.id === action.payload)
      }
      if(p.fixture) {
        p.fixture.isFavorite = !p.fixture.isFavorite;
        if(p.league) {
          p.league.isFavorite = leagueFixtures?.fixtures.some(f => f.isFavorite) ?? false;
        }
      }
    },
    toggleFavoriteLeague: (s, action) => {
      const leagueFixture = s.leaguesFixtures.find(
        (lf) => lf.league.id == action.payload
      );
      if (leagueFixture) {
        leagueFixture.league.isFavorite = !leagueFixture.league.isFavorite;
        const fixturesOfLeague = leagueFixture.fixtures;
        if (leagueFixture.league.isFavorite) {
          // se league è stato aggiunto come preferito, aggiorniamo il valore di isFavorite dei fixture di quella league
          fixturesOfLeague.forEach((fixture) => fixture.isFavorite = true);
        } else {
          // se league è stato rimosso come preferito, aggiorniamo il valore di isFavorite dei fixture di quella league
          fixturesOfLeague.forEach((fixture) => fixture.isFavorite = false);
        }
      }
    },
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
      // Handle the action types defined by the `incrementAsync` thunk defined below.
      // This lets the slice reducer update the state with request status and results.
      .addCase(fetchFixtures.pending, (s) => {
        s.status = "loading";
      })
      .addCase(fetchFixtures.fulfilled, (s, action) => {
        s.status = "idle";

        // get favoriteFixtures from API response
        const fixtures = sortFixturesByDate(
          action.payload
          .map((fixtureResponse) => fixtureResponse.response)
          .flat()
          // settiamo isFavorite a false per default
          .map((fixture) => ({ ...fixture, isFavorite: false }))
        ); // TODO: se l'utente loggato, prendiamo il valore da db

        // get favoriteLeagues from above favoriteFixtures
        const leagues = Array.from(
          new Map(
            fixtures
              .map((fixture) => fixture.league)
              .map((league) => [league.id, { ...league, isFavorite: false }])
          ).values()
        ); // TODO: se l'utente loggato, prendiamo il valore da db

        const leaguesFixtures = leagues.map((league) => {
          const fixturesOfLeague = fixtures.filter(
            (fixture) => fixture.league.id === league.id
          );
          return {
            league: league,
            fixtures: fixturesOfLeague,
          };
        }).sort((a, b) => defaultSortingLeagues(a.league.id, b.league.id));

        s.fixtures = fixtures; // sort fixtures by date
        s.leagues = leagues;
        s.leaguesFixtures = leaguesFixtures;
      })
      .addCase(fetchFixtures.rejected, (state) => {
        state.status = "failed";
      });
  },
});

export default footballSlice.reducer;
export const { toggleFavoriteFixture, toggleFavoriteLeague } = footballSlice.actions;

export const fetchFixtures = createAsyncThunk(
  "fixtures/fetchFixtures",
  async (params: getAPIFootballParams) => {
    let response: FixtureResponse[];
    if (!config.mockAPICall) {
      ////console.log("params in the fetchFixtures slice: ", params.queryParams);
      // perform the api call if no fixtureResponse is provided
      response = await fetch(
        `/api/api-football/get-fixtures` +
          `${qs.stringify(params.queryParams)}`,
        {
          method: "GET",
          headers: {
            "Content-Type": "application/json",
          },
        }
      ).then(async (res) => {
        return (await res.json()) as FixtureResponse[];
      });
    } else {
      // return the mock fixtures
      response = [mockFixtures] as unknown as FixtureResponse[];
      ////console.log("mock response at slice level: ", response);
    }
    return response;
  }
);

export const getFixturesIds = (fixtures: FavoriteFixture[]) => {
  return fixtures.map((fixture) => fixture.fixture.id);
};

export const getLeaguesIds = (leagues: FavoriteLeague[]) => {
  return leagues.map((league) => league.id);
};

/**
 * Extract the fixtures of a given league from a given fixtures[]
 * @param fixtures a fixtures[]
 * @param leagueId the id of the league
 * @returns the fixtures of a league
 */
export const extractFixturesByLeague = (
  fixtures: FavoriteFixture[],
  leagueId: number
): FavoriteFixture[] => {
  return fixtures.filter(
    (fixture) => fixture.league.id === leagueId
  ) as FavoriteFixture[];
};

/**
 * This function is used in dirette-table.tsx to get the correct format to feed to the table, out of the fixtures[] of the store
 * @param fixtures
 * @param filterSortParams params for filtering and sorting
 * @returns LeagueFixtures
 */
export const selectLeagueFixturesByDay = (
  s: FootballState,
  selectedDay: Date
): FavoriteLeagueFixture[] => {
  // costruisci leagueFixtures
  //console.log("selectedDay: ", selectedDay, s.leaguesFixtures.length)
  
  let diretteByDay = s.leaguesFixtures
  .map(lf => ({
    league: lf.league, 
    fixtures: lf.fixtures.filter(f =>  {
      //console.log("f.fixture.date: ", f.fixture.date, "selectedDay: ", selectedDay); 
      return (new Date(f.fixture.date)).toDateString() == selectedDay.toDateString()
    })
  })) // per ogni leagueFixture, mantieni solo le fixtures della data selezionata
  //console.log("diretteByDay: ", diretteByDay)
  diretteByDay = diretteByDay.filter(lf => lf.fixtures.length > 0) // rimuovi le leagueFixtures a cui non rimangono fixtures
  return diretteByDay;
};

export const getFavouriteLeagueFixtures = (lfs: FavoriteLeagueFixture[]): FavoriteLeagueFixture[] => {
 return lfs.map(lf => {
  const hasSomeFavouriteFixture = lf.fixtures.some(f => f.isFavorite)
  if(hasSomeFavouriteFixture) { // se la lf ha qualche favorite fixture, mantieni la lf e filtra le fixtures per isFavorite
    return {
      league: lf.league,
      fixtures: lf.fixtures.filter(f => f.isFavorite)
    }
  }
  return [];
}).flat() // flatten per rimuovere i []
}

const sortFixturesByDate = (fixtures: FavoriteFixture[]) => {
  // Create a new array before sorting
  const sortedFixtures = [...fixtures].sort((a, b) =>
    compareDates(a.fixture.date, b.fixture.date)
  );
  return sortedFixtures;
};
const defaultSortingLeagues = (leagueId1: number, leagueId2: number): number => {
    // the ids of the leagues to be shown first
    const firstIds = [ 135, 78, 39, 41, 140, 136]
    if(!firstIds.includes(leagueId1) && !firstIds.includes(leagueId2)) return 1;
    if(firstIds.includes(leagueId1) && !firstIds.includes(leagueId2)) return -1;
    if(!firstIds.includes(leagueId1) && firstIds.includes(leagueId2)) return 1;
    if(firstIds.includes(leagueId1) && firstIds.includes(leagueId2)) return firstIds.indexOf(leagueId1) - firstIds.indexOf(leagueId2);
    return 0;
}