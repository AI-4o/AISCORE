import { createAsyncThunk, createSlice, createSelector } from "@reduxjs/toolkit";
import {
  FavoriteFixture,
  FavoriteLeague,
  FavoriteLeagueFixture,
  FixtureResponse,
} from "@/app/api/api-football/models/footballModels";
import mockFixtures from "api/api-football/mock-responses/mock-fixtures/mock-fixtures-1.json";
import { getAPIFootballParams } from "@/app/api/api-football/api-call.defs";
import { config } from "appConfig";
import qs from "qs";
import { compareDates } from "@/app/lib/utils";

export interface FootballState {
  fixtures: FavoriteFixture[];
  leagues: FavoriteLeague[];
  leaguesFixtures: FavoriteLeagueFixture[];
  status: "idle" | "loading" | "failed";
}

const initialState: FootballState = {
  fixtures: [],
  leagues: [],
  leaguesFixtures: [],
  status: "idle",
};
// Slice -> used to create in 1 place reducers and actions logic,
// - slice.actions returns the action creators
// - slice.reducer returns the reducer
export const footballSlice = createSlice({
  name: "fixtures",
  initialState,
  reducers: {
    toggleFavoriteFixture: (s, action) => {
      const leagueFixtures = s.leaguesFixtures.find( // find the leagueFixtures object associated to the fixture
        (leagueFixture) => leagueFixture.fixtures.find(f => f.fixture.id === action.payload)
      )
      const p = {
        league: leagueFixtures?.league,
        fixture: leagueFixtures?.fixtures.find(f => f.fixture.id === action.payload)
      }
      if(p.fixture) {
        p.fixture.isFavorite = !p.fixture.isFavorite;
        if(p.league) {
          p.league.isFavorite = leagueFixtures?.fixtures.some(f => f.isFavorite) ?? false;
        }
      }
    },
    toggleFavoriteLeague: (s, action) => {
      const leagueFixture = s.leaguesFixtures.find(
        (lf) => lf.league.id == action.payload
      );
      if (leagueFixture) {
        leagueFixture.league.isFavorite = !leagueFixture.league.isFavorite;
        const fixturesOfLeague = leagueFixture.fixtures;
        if (leagueFixture.league.isFavorite) {
          // se league è stato aggiunto come preferito, aggiorniamo il valore di isFavorite dei fixture di quella league
          fixturesOfLeague.forEach((fixture) => fixture.isFavorite = true);
        } else {
          // se league è stato rimosso come preferito, aggiorniamo il valore di isFavorite dei fixture di quella league
          fixturesOfLeague.forEach((fixture) => fixture.isFavorite = false);
        }
      }
    },
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
      // Handle the action types defined by the `incrementAsync` thunk defined below.
      // This lets the slice reducer update the state with request status and results.
      .addCase(fetchFixtures.pending, (s) => {
        s.status = "loading";
      })
      .addCase(fetchFixtures.fulfilled, (s, action) => {
        s.status = "idle";

        // get favoriteFixtures from API response
        const fixtures = sortFixturesByDate(
          action.payload
          .map((fixtureResponse) => fixtureResponse.response)
          .flat()
          // settiamo isFavorite a false per default
          .map((fixture) => ({ ...fixture, isFavorite: false }))
        ); // TODO: se l'utente loggato, prendiamo il valore da db
        // get favoriteLeagues from above favoriteFixtures
        const leagues = Array.from(
          new Map(
            fixtures
              .map((fixture) => fixture.league)
              .map((league) => [league.id, { ...league, isFavorite: false }])
          ).values()
        ); // TODO: se l'utente loggato, prendiamo il valore da db

        const leaguesFixtures = leagues.map((league) => {
          const fixturesOfLeague = fixtures.filter(
            (fixture) => fixture.league.id === league.id
          );
          return {
            league: league,
            fixtures: fixturesOfLeague,
          };
        }).sort((a, b) => defaultSortingLeagues(a.league.id, b.league.id));
        //// console.log("leaguesFixtures: ", leaguesFixtures);
        s.fixtures = fixtures; // sort fixtures by date
        s.leagues = leagues;
        s.leaguesFixtures = leaguesFixtures;
      })
      .addCase(fetchFixtures.rejected, (state) => {
        state.status = "failed";
      });
  },
});

export default footballSlice.reducer;
export const { toggleFavoriteFixture, toggleFavoriteLeague } = footballSlice.actions;

export const fetchFixtures = createAsyncThunk(
  "fixtures/fetchFixtures",
  async () => {
    let response: FixtureResponse[];
    if (!config.mockAPICall) {
      ////// console.log("params in the fetchFixtures slice: ", params.queryParams);
      // perform the api call if no fixtureResponse is provided
      response = await fetch(
        `/api/api-football/get-fixtures`,
        {
          method: "GET",
          headers: {
            "Content-Type": "application/json",
          },
        }
      ).then(async (res) => {
        return (await res.json()) as FixtureResponse[];
      });
    } else {
      // return the mock fixtures
      response = [mockFixtures] as unknown as FixtureResponse[];
      ////// console.log("mock response at slice level: ", response);
    }
    return response;
  }
);

// Selettori esistenti sostituiti con versioni memorizzate

/**
 * Questo selettore recupera lo stato delle fixture di football
 */
const selectFootballState = (state: { football: FootballState }) => state.football;

/**
 * Selettore memoizzato per estrarre le fixture per lega
 */
export const extractFixturesByLeague = createSelector(
  [(fixtures: FavoriteFixture[]) => fixtures, (_: any, leagueId: number) => leagueId],
  (fixtures, leagueId): FavoriteFixture[] => {
    return fixtures.filter(
      (fixture) => fixture.league.id === leagueId
    ) as FavoriteFixture[];
  }
);

/**
 * Selettore memoizzato per recuperare le fixture raggruppate per lega in una data specifica
 * Questo risolve il problema di selectLeagueFixturesByDay che crea nuovi oggetti ogni volta
 */
export const selectLeagueFixturesByDay = createSelector(
  [selectFootballState, (_: any, selectedDay: Date) => selectedDay],
  (footballState, selectedDay): FavoriteLeagueFixture[] => {
    // costruisci leagueFixtures
    let diretteByDay = footballState.leaguesFixtures
    .map(lf => ({
      league: lf.league, 
      fixtures: lf.fixtures.filter(f =>  {
        return (new Date(f.fixture.date)).toDateString() === new Date(selectedDay).toDateString()
      })
    })) 
    
    // rimuovi le leagueFixtures a cui non rimangono fixtures
    diretteByDay = diretteByDay.filter(lf => lf.fixtures.length > 0) 
    
    return diretteByDay;
  }
);

/**
 * Selettore memoizzato per recuperare le fixture preferite raggruppate per lega
 */
export const getFavouriteLeagueFixtures = createSelector(
  [(lfs: FavoriteLeagueFixture[]) => lfs],
  (lfs): FavoriteLeagueFixture[] => {
    return lfs.map(lf => {
      const hasSomeFavouriteFixture = lf.fixtures.some(f => f.isFavorite)
      if(hasSomeFavouriteFixture) { // se la lf ha qualche favorite fixture, mantieni la lf e filtra le fixtures per isFavorite
        return {
          league: lf.league,
          fixtures: lf.fixtures.filter(f => f.isFavorite)
        }
      }
      return [];
    }).flat() // flatten per rimuovere i []
  }
);

// Utility per ottenere gli ID
export const getFixturesIds = createSelector(
  [(fixtures: FavoriteFixture[]) => fixtures],
  (fixtures): number[] => {
    return fixtures.map((fixture) => fixture.fixture.id);
  }
);

export const getLeaguesIds = createSelector(
  [(leagues: FavoriteLeague[]) => leagues],
  (leagues): number[] => {
    return leagues.map((league) => league.id);
  }
);

const sortFixturesByDate = (fixtures: FavoriteFixture[]) => {
  // Create a new array before sorting
  const sortedFixtures = [...fixtures].sort((a, b) =>
    compareDates(a.fixture.date, b.fixture.date)
  );
  return sortedFixtures;
};
const defaultSortingLeagues = (leagueId1: number, leagueId2: number): number => {
    // the ids of the leagues to be shown first
    const firstIds = [ 135, 78, 39, 41, 140, 136]
    if(!firstIds.includes(leagueId1) && !firstIds.includes(leagueId2)) return 1;
    if(firstIds.includes(leagueId1) && !firstIds.includes(leagueId2)) return -1;
    if(!firstIds.includes(leagueId1) && firstIds.includes(leagueId2)) return 1;
    if(firstIds.includes(leagueId1) && firstIds.includes(leagueId2)) return firstIds.indexOf(leagueId1) - firstIds.indexOf(leagueId2);
    return 0;
}