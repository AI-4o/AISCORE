import {
  createAsyncThunk,
  createSlice,
  createSelector,
} from "@reduxjs/toolkit";
import {
  FavoriteFixture,
  FavoriteLeague,
  FavoriteLeagueFixture,
  Fixture,
  FixtureResponse,
  Player,
} from "@/app/api/api-football/models/footballModels";
import { compareDates } from "@/app/lib/utils";
import { RootState } from "../../store";

export interface FootballState {
  fixtures: FavoriteFixture[];
  leagues: FavoriteLeague[];
  leaguesFixtures: FavoriteLeagueFixture[];
  players: Player[];
  favoritePlayers: Player[];
  status: "idle" | "loading" | "failed";
}

const initialState: FootballState = {
  fixtures: [],
  leagues: [],
  leaguesFixtures: [],
  players: [],
  favoritePlayers: [],
  status: "idle",
};
// Slice -> used to create in 1 place reducers and actions logic,
// - slice.actions returns the action creators
// - slice.reducer returns the reducer
export const footballSlice = createSlice({
  name: "fixtures",
  initialState,
  reducers: {
    toggleFavoriteFixture: (s, action) => {
      const leagueFixtures = s.leaguesFixtures.find(
        // find the leagueFixtures object associated to the fixture
        (leagueFixture) =>
          leagueFixture.fixtures.find((f) => f.fixture.id === action.payload)
      );
      const p = {
        league: leagueFixtures?.league,
        fixture: leagueFixtures?.fixtures.find(
          (f) => f.fixture.id === action.payload
        ),
      };
      if (p.fixture) {
        p.fixture.isFavorite = !p.fixture.isFavorite;
        if (p.league) {
          p.league.isFavorite =
            leagueFixtures?.fixtures.some((f) => f.isFavorite) ?? false;
        }
      }
    },
    toggleFavoriteLeague: (s, action) => {
      const leagueFixture = s.leaguesFixtures.find(
        (lf) => lf.league.id == action.payload
      );
      if (leagueFixture) {
        leagueFixture.league.isFavorite = !leagueFixture.league.isFavorite;
        const fixturesOfLeague = leagueFixture.fixtures;
        if (leagueFixture.league.isFavorite) {
          // se league è stato aggiunto come preferito, aggiorniamo il valore di isFavorite dei fixture di quella league
          fixturesOfLeague.forEach((fixture) => (fixture.isFavorite = true));
        } else {
          // se league è stato rimosso come preferito, aggiorniamo il valore di isFavorite dei fixture di quella league
          fixturesOfLeague.forEach((fixture) => (fixture.isFavorite = false));
        }
      }
    },
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
      // Handle the action types defined by the `incrementAsync` thunk defined below.
      // This lets the slice reducer update the state with request status and results.
      .addCase(fetchFixtures.pending, (s) => {
        s.status = "loading";
      })
      .addCase(fetchFixtures.fulfilled, (s, action) => {
        s.status = "idle";

        // get favoriteFixtures from API response
        const fixtures = sortFixturesByDate(
          action.payload
            .map((fixtureResponse) => fixtureResponse.response)
            .flat()
            // settiamo isFavorite a false per default
            .map((fixture) => ({ ...fixture, isFavorite: false }))
        ); // TODO: se l'utente loggato, prendiamo il valore da db
        // get favoriteLeagues from above favoriteFixtures
        const leagues = Array.from(
          new Map(
            fixtures
              .map((fixture) => fixture.league)
              .map((league) => [league.id, { ...league, isFavorite: false }])
          ).values()
        ); // TODO: se l'utente loggato, prendiamo il valore da db

        const leaguesFixtures = leagues
          .map((league) => {
            const fixturesOfLeague = fixtures.filter(
              (fixture) => fixture.league.id === league.id
            );
            return {
              league: league,
              fixtures: fixturesOfLeague,
            };
          })
          .sort((a, b) => defaultSortingLeagues(a.league.id, b.league.id));
        //// console.log("leaguesFixtures: ", leaguesFixtures);
        s.fixtures = fixtures; // sort fixtures by date
        s.leagues = leagues;
        s.leaguesFixtures = leaguesFixtures;
      })
      .addCase(fetchFixtures.rejected, (state) => {
        state.status = "failed";
      });
  },
});

export default footballSlice.reducer;
export const { toggleFavoriteFixture, toggleFavoriteLeague } =
  footballSlice.actions;

export const fetchFixtures = createAsyncThunk(
  "fixtures/fetchFixtures",
  async () => {
    return await fetch(`/api/api-football/get-fixtures`, {
      method: "GET",
      headers: {
        "Content-Type": "application/json",
      },
    }).then(async (res) => {
      return (await res.json()) as FixtureResponse[];
    });
  }
);

// SELETTORI
export const selectFootballState = (s: RootState) => s.football;
export const sStatus = createSelector(
  [selectFootballState],
  (footballState) => footballState.status
);
export const sFixtures = createSelector(
  [selectFootballState],
  (footballState) => footballState.fixtures
);
export const sLeagues = createSelector(
  [selectFootballState],
  (footballState) => footballState.leagues
);
export const sLeaguesFixtures = createSelector(
  [selectFootballState],
  (footballState) => footballState.leaguesFixtures
);

/**
 * Selettore per recuperare le leghe preferite
 */
export const sFavoriteLeaguesFixtures = createSelector(
  [sLeaguesFixtures],
  (leaguesFixtures) => {
    const favorites = leaguesFixtures
      .filter((lf) => lf.league.isFavorite)
      .map((lf) => {
        return {
          league: lf.league,
          fixtures: lf.fixtures.filter((f) => f.isFavorite),
        };
      });
    console.log("favorites: ", favorites);
    return favorites;
  }
);

export const sFavoriteLeaguesFixturesByDay = createSelector(
  [sFavoriteLeaguesFixtures, (_: any, selectedDay: Date) => selectedDay],
  (favoriteLeaguesFixtures, selectedDay): FavoriteLeagueFixture[] => {
    return favoriteLeaguesFixtures.map((lf) => {
      return {
        league: lf.league,
        fixtures: lf.fixtures.filter((f) => {
          return new Date(f.fixture.date).toDateString() === new Date(selectedDay).toDateString();
        }),
      };
    })
    .filter((lf) => lf.fixtures.length > 0);
  }
);

export const sFixturesByLeague = createSelector(
  [sFixtures, (_: any, leagueId: number) => leagueId],
  (fixtures, leagueId): Fixture[] => {
    return fixtures.filter(
      (fixture) => fixture.league.id === leagueId
    ) as Fixture[];
  }
);

export const sLeagueFixturesByDay = createSelector(
  [sLeaguesFixtures, (_: any, selectedDay: Date) => selectedDay],
  (leaguesFixtures, selectedDay): FavoriteLeagueFixture[] => {
    // costruisci leagueFixtures
    let lfByDay = leaguesFixtures
      .map((lf) => ({
        // tra le fixtures di ogni leagueFixture mantieni solo quelle del giorno selezionato
        league: lf.league,
        fixtures: lf.fixtures.filter((f) => {
          return (
            new Date(f.fixture.date).toDateString() ===
            new Date(selectedDay).toDateString()
          );
        }),
      }))
      .filter((lf) => lf.fixtures.length > 0);
    return lfByDay;
  }
);

// Utility per ottenere gli ID
export const getFixturesIds = createSelector(
  [(fixtures: FavoriteFixture[]) => fixtures],
  (fixtures): number[] => {
    return fixtures.map((fixture) => fixture.fixture.id);
  }
);

export const getLeaguesIds = createSelector(
  [(leagues: FavoriteLeague[]) => leagues],
  (leagues): number[] => {
    return leagues.map((league) => league.id);
  }
);

const sortFixturesByDate = (fixtures: FavoriteFixture[]) => {
  // Create a new array before sorting
  const sortedFixtures = [...fixtures].sort((a, b) =>
    compareDates(a.fixture.date, b.fixture.date)
  );
  return sortedFixtures;
};
const defaultSortingLeagues = (
  leagueId1: number,
  leagueId2: number
): number => {
  // the ids of the leagues to be shown first
  const firstIds = [135, 78, 39, 41, 140, 136];
  if (!firstIds.includes(leagueId1) && !firstIds.includes(leagueId2)) return 1;
  if (firstIds.includes(leagueId1) && !firstIds.includes(leagueId2)) return -1;
  if (!firstIds.includes(leagueId1) && firstIds.includes(leagueId2)) return 1;
  if (firstIds.includes(leagueId1) && firstIds.includes(leagueId2))
    return firstIds.indexOf(leagueId1) - firstIds.indexOf(leagueId2);
  return 0;
};
